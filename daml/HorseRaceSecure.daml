module HorseRaceSecure where

import DA.List (sort)
import DA.Text (sha256, explode)
import qualified DA.Text as Text
import DA.Optional (fromOptional, isSome)

-- | Horse identifiers (5 horses per race)
data Horse = Red | Blue | Green | Yellow | Purple
  deriving (Eq, Show, Ord)

-- | Race states
data RaceState
  = Committed      -- Seed committed, betting open
  | BettingClosed  -- Betting deadline passed
  | Running        -- Seed revealed, race executing
  | Finished       -- Winner determined
  | Cancelled      -- Race cancelled, refunds allowed
  deriving (Eq, Show)

-- | Settlement result returned when settling a Bet
data SettlementResult
  = Won (ContractId Payout)
  | Lost
  | Refunded (ContractId RefundReceipt)
  deriving (Eq, Show)

-- | Deterministic race units
finishLine : Int
finishLine = 100

allHorses : [Horse]
allHorses = [Red, Blue, Green, Yellow, Purple]

defaultOdds : [(Horse, Decimal)]
defaultOdds =
  [ (Red, 2.5)
  , (Blue, 3.5)
  , (Green, 5.0)
  , (Yellow, 8.0)
  , (Purple, 12.0)
  ]

-- | Root contract for the house/operator
template Operator
  with
    operator : Party
  where
    signatory operator

    -- Create a new player account
    nonconsuming choice CreatePlayerAccount : ContractId PlayerAccount
      with
        player : Party
      controller operator
      do
        create PlayerAccount with
          operator
          player
          balance = 0.0

    -- Create a new race with committed seed
    nonconsuming choice CreateRace : ContractId Race
      with
        raceId : Text
        seedCommitment : Text  -- SHA256 hash of the seed
        bettingDeadline : Time
      controller operator
      do
        create Race with
          operator
          raceId
          seedCommitment
          seed = None
          state = Committed
          bettingDeadline
          winner = None
          positions = [(h, 0) | h <- allHorses]
          tickNumber = 0
          odds = defaultOdds
          totalLiability = 0.0
          horseLiability = []

-- | Player account with balance management
template PlayerAccount
  with
    operator : Party
    player : Party
    balance : Decimal
  where
    signatory operator
    observer player

    -- Deposit funds (simulated for testnet)
    choice Deposit : ContractId PlayerAccount
      with
        amount : Decimal
      controller player
      do
        assertMsg "Deposit amount must be positive" (amount > 0.0)
        create this with balance = balance + amount

    -- Withdraw funds (requires operator approval for now)
    choice Withdraw : ContractId PlayerAccount
      with
        amount : Decimal
      controller player
      do
        assertMsg "Withdrawal amount must be positive" (amount > 0.0)
        assertMsg "Insufficient balance" (balance >= amount)
        create this with balance = balance - amount

    -- Create a bet request
    nonconsuming choice PlaceBetRequest : ContractId BetRequest
      with
        raceId : Text
        horse : Horse
        amount : Decimal
      controller player
      do
        assertMsg "Bet amount must be positive" (amount > 0.0)
        assertMsg "Insufficient balance" (balance >= amount)
        create BetRequest with
          operator
          player
          raceId
          horse
          amount

-- | Player-initiated bet request
template BetRequest
  with
    operator : Party
    player : Party
    raceId : Text
    horse : Horse
    amount : Decimal
  where
    signatory player
    observer operator

    -- Operator accepts the bet
    choice AcceptBet : (ContractId PlayerAccount, ContractId Race, ContractId Bet)
      with
        accountCid : ContractId PlayerAccount
        raceCid : ContractId Race
        maxLiabilityPerHorse : Decimal
        currentTime : Time
      controller operator
      do
        -- Verify race state
        race <- fetch raceCid
        assertMsg "Race not in Committed state" (race.state == Committed)
        assertMsg "Betting deadline passed" (race.bettingDeadline > currentTime)
        assertMsg "RaceId mismatch" (race.raceId == raceId)

        -- Check liability limits
        let currentLiability = calculateHorseLiability race.horseLiability horse
        let odds = lookupOdds race.odds horse
        assertMsg "Odds not configured for horse" (odds > 0.0)
        let potentialPayout = amount * odds
        assertMsg "Exceeds liability cap" (currentLiability + potentialPayout <= maxLiabilityPerHorse)

        -- Deduct from player account
        account <- fetch accountCid
        assertMsg "Account mismatch" (account.player == player)
        assertMsg "Insufficient balance" (account.balance >= amount)
        exercise accountCid Archive
        updatedAccountCid <- create account with balance = account.balance - amount

        -- Update race liability
        updatedRaceCid <- exercise raceCid UpdateLiability with
          horse
          additionalLiability = potentialPayout

        -- Create bet contract
        betCid <- create Bet with
          operator
          player
          raceId
          horse
          amount
          odds

        return (updatedAccountCid, updatedRaceCid, betCid)

    -- Player cancels bet request before acceptance
    choice CancelBetRequest : ()
      controller player
      do
        return ()

-- | Active bet contract
template Bet
  with
    operator : Party
    player : Party
    raceId : Text
    horse : Horse
    amount : Decimal
    odds : Decimal
  where
    signatory operator, player

    -- Settle bet based on race outcome (consumes Bet)
    choice Settle : SettlementResult
      with
        raceCid : ContractId Race
      controller operator
      do
        race <- fetch raceCid
        assertMsg "RaceId mismatch" (race.raceId == raceId)
        assertMsg "Race not finished or cancelled" (race.state == Finished || race.state == Cancelled)
        if race.state == Cancelled then do
          refundCid <- create RefundReceipt with
            operator
            player
            raceId
            amount
          return (Refunded refundCid)
        else do
          let winnerHorse = fromOptional Red race.winner -- should always be Some in Finished
          if horse == winnerHorse then do
            let payoutAmount = amount * odds
            payoutCid <- create Payout with
              operator
              player
              raceId
              amount = payoutAmount
            return (Won payoutCid)
          else
            return Lost

-- | Payout for winning bets
template Payout
  with
    operator : Party
    player : Party
    raceId : Text
    amount : Decimal
  where
    signatory operator
    observer player

    -- Player claims payout to their account
    choice ClaimPayout : ContractId PlayerAccount
      with
        accountCid : ContractId PlayerAccount
      controller player
      do
        account <- fetch accountCid
        assertMsg "Account mismatch" (account.player == player)

        exercise accountCid Archive
        create account with balance = account.balance + amount

-- | Refund receipt for cancelled bets
template RefundReceipt
  with
    operator : Party
    player : Party
    raceId : Text
    amount : Decimal
  where
    signatory operator
    observer player

    -- Player claims refund to their account
    choice ClaimRefund : ContractId PlayerAccount
      with
        accountCid : ContractId PlayerAccount
      controller player
      do
        account <- fetch accountCid
        assertMsg "Account mismatch" (account.player == player)

        exercise accountCid Archive
        create account with balance = account.balance + amount

-- | Race state machine
template Race
  with
    operator : Party
    raceId : Text
    seedCommitment : Text  -- SHA256 of seed
    seed : Optional Text   -- Revealed seed
    state : RaceState
    bettingDeadline : Time
    winner : Optional Horse
    positions : [(Horse, Int)] -- 0..finishLine
    tickNumber : Int
    odds : [(Horse, Decimal)]
    totalLiability : Decimal
    horseLiability : [(Horse, Decimal)]
  where
    signatory operator

    -- Close betting after deadline
    choice CloseBetting : ContractId Race
      with
        currentTime : Time
      controller operator
      do
        assertMsg "Race not in Committed state" (state == Committed)
        assertMsg "Betting deadline not reached" (bettingDeadline <= currentTime)

        create this with state = BettingClosed

    -- Reveal seed and start race
    choice RevealSeed : ContractId Race
      with
        revealedSeed : Text
      controller operator
      do
        assertMsg "Race not in BettingClosed state" (state == BettingClosed)

        -- Verify seed commitment
        let computedHash = sha256 revealedSeed
        assertMsg "Seed does not match commitment" (computedHash == seedCommitment)

        create this with
          seed = Some revealedSeed
          state = Running

    -- Advance the race by one tick (deterministic from revealed seed + tickNumber)
    choice Tick : ContractId Race
      controller operator
      do
        assertMsg "Race not in Running state" (state == Running)
        assertMsg "Seed not revealed" (isSome seed)
        let revealedSeed = fromOptional "" seed
        let updatedPositions = advancePositions revealedSeed tickNumber positions
        let (isFinished, maybeWinner) = determineWinner updatedPositions
        if isFinished then
          create this with
            state = Finished
            positions = updatedPositions
            winner = maybeWinner
            tickNumber = tickNumber + 1
        else
          create this with
            positions = updatedPositions
            tickNumber = tickNumber + 1

    -- Non-consuming choice to get winner (for settlement verification)
    nonconsuming choice GetWinner : Optional Horse
      controller operator
      do
        return winner

    -- Cancel a race (operator safety valve)
    choice Cancel : ContractId Race
      controller operator
      do
        create this with
          state = Cancelled
          winner = None

    -- Update liability tracking
    choice UpdateLiability : ContractId Race
      with
        horse : Horse
        additionalLiability : Decimal
      controller operator
      do
        let updatedHorseLiability = updateHorseLiability horseLiability horse additionalLiability
        create this with
          totalLiability = totalLiability + additionalLiability
          horseLiability = updatedHorseLiability

-- Helper functions

-- Lookup odds for a horse
lookupOdds : [(Horse, Decimal)] -> Horse -> Decimal
lookupOdds table h =
  case lookup h table of
    None -> 0.0
    Some o -> o

-- Convert a single hex character (as Text) to Int 0..15
hexNibble : Text -> Int
hexNibble c = case c of
  "0" -> 0
  "1" -> 1
  "2" -> 2
  "3" -> 3
  "4" -> 4
  "5" -> 5
  "6" -> 6
  "7" -> 7
  "8" -> 8
  "9" -> 9
  "a" -> 10
  "b" -> 11
  "c" -> 12
  "d" -> 13
  "e" -> 14
  "f" -> 15
  "A" -> 10
  "B" -> 11
  "C" -> 12
  "D" -> 13
  "E" -> 14
  "F" -> 15
  _ -> 0

-- Deterministic movement 1..15 for a given (seed, tick, horse)
movementFor : Text -> Int -> Horse -> Int
movementFor seed tick horse =
  let h = sha256 (seed <> ":" <> show tick <> ":" <> show horse)
      chars = explode (Text.take 2 h) -- first two hex chars
      hi = case chars of
        (a :: b :: _) -> (hexNibble a) * 16 + (hexNibble b)
        _ -> 0
      mod15 = hi - ((hi / 15) * 15)
  in mod15 + 1

advancePositions : Text -> Int -> [(Horse, Int)] -> [(Horse, Int)]
advancePositions seed tick ps =
  [ (h, min finishLine (p + movementFor seed tick h))
  | (h, p) <- ps
  ]

determineWinner : [(Horse, Int)] -> (Bool, Optional Horse)
determineWinner ps =
  let finished = filter (\(_, p) -> p >= finishLine) ps
  in case finished of
      [] -> (False, None)
      _ ->
        -- pick the horse with the highest position; tie-break by Horse ordering
        let sorted = reverse (sort finished)
            (h, _) = case sorted of
              ((hh, pp) :: _) -> (hh, pp)
              _ -> (Red, 0)
        in (True, Some h)

-- Calculate current liability for a specific horse
calculateHorseLiability : [(Horse, Decimal)] -> Horse -> Decimal
calculateHorseLiability liabilities targetHorse =
  let matching = filter (\(h, _) -> h == targetHorse) liabilities
  in case matching of
      [] -> 0.0
      ((_, amount) :: _) -> amount

-- Update horse liability tracking
updateHorseLiability : [(Horse, Decimal)] -> Horse -> Decimal -> [(Horse, Decimal)]
updateHorseLiability liabilities horse additionalLiability =
  let currentLiability = calculateHorseLiability liabilities horse
      newLiability = currentLiability + additionalLiability
      filtered = filter (\(h, _) -> h /= horse) liabilities
  in (horse, newLiability) :: filtered
